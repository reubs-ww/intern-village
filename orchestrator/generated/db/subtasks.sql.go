// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subtasks.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createSubtask = `-- name: CreateSubtask :one

INSERT INTO subtasks (
    task_id,
    title,
    spec,
    implementation_plan,
    status,
    position,
    beads_issue_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at
`

type CreateSubtaskParams struct {
	TaskID             uuid.UUID `json:"task_id"`
	Title              string    `json:"title"`
	Spec               *string   `json:"spec"`
	ImplementationPlan *string   `json:"implementation_plan"`
	Status             string    `json:"status"`
	Position           int32     `json:"position"`
	BeadsIssueID       *string   `json:"beads_issue_id"`
}

// Subtasks SQL queries
// Reference: specs/orchestrator.md ยง4.4
func (q *Queries) CreateSubtask(ctx context.Context, arg CreateSubtaskParams) (Subtask, error) {
	row := q.db.QueryRow(ctx, createSubtask,
		arg.TaskID,
		arg.Title,
		arg.Spec,
		arg.ImplementationPlan,
		arg.Status,
		arg.Position,
		arg.BeadsIssueID,
	)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSubtask = `-- name: DeleteSubtask :exec
DELETE FROM subtasks
WHERE id = $1
`

func (q *Queries) DeleteSubtask(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSubtask, id)
	return err
}

const getNextPosition = `-- name: GetNextPosition :one
SELECT COALESCE(MAX(position), 0) + 1 AS next_position
FROM subtasks
WHERE task_id = $1
`

func (q *Queries) GetNextPosition(ctx context.Context, taskID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getNextPosition, taskID)
	var next_position int32
	err := row.Scan(&next_position)
	return next_position, err
}

const getSubtaskByBeadsID = `-- name: GetSubtaskByBeadsID :one
SELECT id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at FROM subtasks
WHERE beads_issue_id = $1 LIMIT 1
`

func (q *Queries) GetSubtaskByBeadsID(ctx context.Context, beadsIssueID *string) (Subtask, error) {
	row := q.db.QueryRow(ctx, getSubtaskByBeadsID, beadsIssueID)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubtaskByID = `-- name: GetSubtaskByID :one
SELECT id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at FROM subtasks
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSubtaskByID(ctx context.Context, id uuid.UUID) (Subtask, error) {
	row := q.db.QueryRow(ctx, getSubtaskByID, id)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubtasksByStatus = `-- name: GetSubtasksByStatus :many
SELECT id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at FROM subtasks
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) GetSubtasksByStatus(ctx context.Context, status string) ([]Subtask, error) {
	rows, err := q.db.Query(ctx, getSubtasksByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subtask{}
	for rows.Next() {
		var i Subtask
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Title,
			&i.Spec,
			&i.ImplementationPlan,
			&i.Status,
			&i.BlockedReason,
			&i.BranchName,
			&i.PrUrl,
			&i.PrNumber,
			&i.RetryCount,
			&i.TokenUsage,
			&i.Position,
			&i.BeadsIssueID,
			&i.WorktreePath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInProgressSubtasks = `-- name: ListInProgressSubtasks :many
SELECT id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at FROM subtasks
WHERE status = 'IN_PROGRESS'
ORDER BY created_at DESC
`

func (q *Queries) ListInProgressSubtasks(ctx context.Context) ([]Subtask, error) {
	rows, err := q.db.Query(ctx, listInProgressSubtasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subtask{}
	for rows.Next() {
		var i Subtask
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Title,
			&i.Spec,
			&i.ImplementationPlan,
			&i.Status,
			&i.BlockedReason,
			&i.BranchName,
			&i.PrUrl,
			&i.PrNumber,
			&i.RetryCount,
			&i.TokenUsage,
			&i.Position,
			&i.BeadsIssueID,
			&i.WorktreePath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubtasksByTask = `-- name: ListSubtasksByTask :many
SELECT id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at FROM subtasks
WHERE task_id = $1
ORDER BY position ASC, created_at ASC
`

func (q *Queries) ListSubtasksByTask(ctx context.Context, taskID uuid.UUID) ([]Subtask, error) {
	rows, err := q.db.Query(ctx, listSubtasksByTask, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Subtask{}
	for rows.Next() {
		var i Subtask
		if err := rows.Scan(
			&i.ID,
			&i.TaskID,
			&i.Title,
			&i.Spec,
			&i.ImplementationPlan,
			&i.Status,
			&i.BlockedReason,
			&i.BranchName,
			&i.PrUrl,
			&i.PrNumber,
			&i.RetryCount,
			&i.TokenUsage,
			&i.Position,
			&i.BeadsIssueID,
			&i.WorktreePath,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubtaskBranch = `-- name: UpdateSubtaskBranch :one
UPDATE subtasks
SET branch_name = $2,
    worktree_path = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at
`

type UpdateSubtaskBranchParams struct {
	ID           uuid.UUID `json:"id"`
	BranchName   *string   `json:"branch_name"`
	WorktreePath *string   `json:"worktree_path"`
}

func (q *Queries) UpdateSubtaskBranch(ctx context.Context, arg UpdateSubtaskBranchParams) (Subtask, error) {
	row := q.db.QueryRow(ctx, updateSubtaskBranch, arg.ID, arg.BranchName, arg.WorktreePath)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubtaskPR = `-- name: UpdateSubtaskPR :one
UPDATE subtasks
SET pr_url = $2,
    pr_number = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at
`

type UpdateSubtaskPRParams struct {
	ID       uuid.UUID `json:"id"`
	PrUrl    *string   `json:"pr_url"`
	PrNumber *int32    `json:"pr_number"`
}

func (q *Queries) UpdateSubtaskPR(ctx context.Context, arg UpdateSubtaskPRParams) (Subtask, error) {
	row := q.db.QueryRow(ctx, updateSubtaskPR, arg.ID, arg.PrUrl, arg.PrNumber)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubtaskPosition = `-- name: UpdateSubtaskPosition :one
UPDATE subtasks
SET position = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at
`

type UpdateSubtaskPositionParams struct {
	ID       uuid.UUID `json:"id"`
	Position int32     `json:"position"`
}

func (q *Queries) UpdateSubtaskPosition(ctx context.Context, arg UpdateSubtaskPositionParams) (Subtask, error) {
	row := q.db.QueryRow(ctx, updateSubtaskPosition, arg.ID, arg.Position)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubtaskRetryCount = `-- name: UpdateSubtaskRetryCount :one
UPDATE subtasks
SET retry_count = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at
`

type UpdateSubtaskRetryCountParams struct {
	ID         uuid.UUID `json:"id"`
	RetryCount int32     `json:"retry_count"`
}

func (q *Queries) UpdateSubtaskRetryCount(ctx context.Context, arg UpdateSubtaskRetryCountParams) (Subtask, error) {
	row := q.db.QueryRow(ctx, updateSubtaskRetryCount, arg.ID, arg.RetryCount)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubtaskStatus = `-- name: UpdateSubtaskStatus :one
UPDATE subtasks
SET status = $2,
    blocked_reason = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at
`

type UpdateSubtaskStatusParams struct {
	ID            uuid.UUID `json:"id"`
	Status        string    `json:"status"`
	BlockedReason *string   `json:"blocked_reason"`
}

func (q *Queries) UpdateSubtaskStatus(ctx context.Context, arg UpdateSubtaskStatusParams) (Subtask, error) {
	row := q.db.QueryRow(ctx, updateSubtaskStatus, arg.ID, arg.Status, arg.BlockedReason)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubtaskTokenUsage = `-- name: UpdateSubtaskTokenUsage :one
UPDATE subtasks
SET token_usage = token_usage + $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, task_id, title, spec, implementation_plan, status, blocked_reason, branch_name, pr_url, pr_number, retry_count, token_usage, position, beads_issue_id, worktree_path, created_at, updated_at
`

type UpdateSubtaskTokenUsageParams struct {
	ID         uuid.UUID `json:"id"`
	TokenUsage int32     `json:"token_usage"`
}

func (q *Queries) UpdateSubtaskTokenUsage(ctx context.Context, arg UpdateSubtaskTokenUsageParams) (Subtask, error) {
	row := q.db.QueryRow(ctx, updateSubtaskTokenUsage, arg.ID, arg.TokenUsage)
	var i Subtask
	err := row.Scan(
		&i.ID,
		&i.TaskID,
		&i.Title,
		&i.Spec,
		&i.ImplementationPlan,
		&i.Status,
		&i.BlockedReason,
		&i.BranchName,
		&i.PrUrl,
		&i.PrNumber,
		&i.RetryCount,
		&i.TokenUsage,
		&i.Position,
		&i.BeadsIssueID,
		&i.WorktreePath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
