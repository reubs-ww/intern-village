// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: agent_runs.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countAgentRunsForSubtask = `-- name: CountAgentRunsForSubtask :one
SELECT COUNT(*) AS count
FROM agent_runs
WHERE subtask_id = $1
`

func (q *Queries) CountAgentRunsForSubtask(ctx context.Context, subtaskID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAgentRunsForSubtask, subtaskID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAgentRunsForTask = `-- name: CountAgentRunsForTask :one
SELECT COUNT(*) AS count
FROM agent_runs
WHERE task_id = $1
`

func (q *Queries) CountAgentRunsForTask(ctx context.Context, taskID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAgentRunsForTask, taskID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAgentRun = `-- name: CreateAgentRun :one

INSERT INTO agent_runs (
    subtask_id,
    agent_type,
    attempt_number,
    status,
    log_path,
    prompt_text
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id
`

type CreateAgentRunParams struct {
	SubtaskID     pgtype.UUID `json:"subtask_id"`
	AgentType     string      `json:"agent_type"`
	AttemptNumber int32       `json:"attempt_number"`
	Status        string      `json:"status"`
	LogPath       string      `json:"log_path"`
	PromptText    string      `json:"prompt_text"`
}

// Agent Runs SQL queries
// Reference: specs/orchestrator.md ยง4.6
// For Worker agents (subtask-level runs)
func (q *Queries) CreateAgentRun(ctx context.Context, arg CreateAgentRunParams) (AgentRun, error) {
	row := q.db.QueryRow(ctx, createAgentRun,
		arg.SubtaskID,
		arg.AgentType,
		arg.AttemptNumber,
		arg.Status,
		arg.LogPath,
		arg.PromptText,
	)
	var i AgentRun
	err := row.Scan(
		&i.ID,
		&i.SubtaskID,
		&i.AgentType,
		&i.AttemptNumber,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.TokenUsage,
		&i.ErrorMessage,
		&i.LogPath,
		&i.PromptText,
		&i.CreatedAt,
		&i.TaskID,
	)
	return i, err
}

const createAgentRunForTask = `-- name: CreateAgentRunForTask :one
INSERT INTO agent_runs (
    task_id,
    agent_type,
    attempt_number,
    status,
    log_path,
    prompt_text
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id
`

type CreateAgentRunForTaskParams struct {
	TaskID        pgtype.UUID `json:"task_id"`
	AgentType     string      `json:"agent_type"`
	AttemptNumber int32       `json:"attempt_number"`
	Status        string      `json:"status"`
	LogPath       string      `json:"log_path"`
	PromptText    string      `json:"prompt_text"`
}

// For Planner agents (task-level runs)
func (q *Queries) CreateAgentRunForTask(ctx context.Context, arg CreateAgentRunForTaskParams) (AgentRun, error) {
	row := q.db.QueryRow(ctx, createAgentRunForTask,
		arg.TaskID,
		arg.AgentType,
		arg.AttemptNumber,
		arg.Status,
		arg.LogPath,
		arg.PromptText,
	)
	var i AgentRun
	err := row.Scan(
		&i.ID,
		&i.SubtaskID,
		&i.AgentType,
		&i.AttemptNumber,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.TokenUsage,
		&i.ErrorMessage,
		&i.LogPath,
		&i.PromptText,
		&i.CreatedAt,
		&i.TaskID,
	)
	return i, err
}

const getAgentRunByID = `-- name: GetAgentRunByID :one
SELECT id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id FROM agent_runs
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAgentRunByID(ctx context.Context, id uuid.UUID) (AgentRun, error) {
	row := q.db.QueryRow(ctx, getAgentRunByID, id)
	var i AgentRun
	err := row.Scan(
		&i.ID,
		&i.SubtaskID,
		&i.AgentType,
		&i.AttemptNumber,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.TokenUsage,
		&i.ErrorMessage,
		&i.LogPath,
		&i.PromptText,
		&i.CreatedAt,
		&i.TaskID,
	)
	return i, err
}

const getLatestAgentRun = `-- name: GetLatestAgentRun :one
SELECT id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id FROM agent_runs
WHERE subtask_id = $1
ORDER BY attempt_number DESC
LIMIT 1
`

func (q *Queries) GetLatestAgentRun(ctx context.Context, subtaskID pgtype.UUID) (AgentRun, error) {
	row := q.db.QueryRow(ctx, getLatestAgentRun, subtaskID)
	var i AgentRun
	err := row.Scan(
		&i.ID,
		&i.SubtaskID,
		&i.AgentType,
		&i.AttemptNumber,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.TokenUsage,
		&i.ErrorMessage,
		&i.LogPath,
		&i.PromptText,
		&i.CreatedAt,
		&i.TaskID,
	)
	return i, err
}

const getLatestAgentRunForTask = `-- name: GetLatestAgentRunForTask :one
SELECT id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id FROM agent_runs
WHERE task_id = $1
ORDER BY attempt_number DESC
LIMIT 1
`

// Get most recent Planner run for a task
func (q *Queries) GetLatestAgentRunForTask(ctx context.Context, taskID pgtype.UUID) (AgentRun, error) {
	row := q.db.QueryRow(ctx, getLatestAgentRunForTask, taskID)
	var i AgentRun
	err := row.Scan(
		&i.ID,
		&i.SubtaskID,
		&i.AgentType,
		&i.AttemptNumber,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.TokenUsage,
		&i.ErrorMessage,
		&i.LogPath,
		&i.PromptText,
		&i.CreatedAt,
		&i.TaskID,
	)
	return i, err
}

const getRunningAgentRuns = `-- name: GetRunningAgentRuns :many
SELECT id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id FROM agent_runs
WHERE status = 'RUNNING'
ORDER BY started_at ASC
`

func (q *Queries) GetRunningAgentRuns(ctx context.Context) ([]AgentRun, error) {
	rows, err := q.db.Query(ctx, getRunningAgentRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AgentRun{}
	for rows.Next() {
		var i AgentRun
		if err := rows.Scan(
			&i.ID,
			&i.SubtaskID,
			&i.AgentType,
			&i.AttemptNumber,
			&i.Status,
			&i.StartedAt,
			&i.EndedAt,
			&i.TokenUsage,
			&i.ErrorMessage,
			&i.LogPath,
			&i.PromptText,
			&i.CreatedAt,
			&i.TaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveAgentRunsByProject = `-- name: ListActiveAgentRunsByProject :many
SELECT
    ar.id,
    ar.subtask_id,
    COALESCE(ar.task_id, s.task_id) AS task_id,
    ar.agent_type,
    ar.status,
    ar.log_path,
    ar.started_at
FROM agent_runs ar
LEFT JOIN subtasks s ON ar.subtask_id = s.id
LEFT JOIN tasks t ON ar.task_id = t.id OR s.task_id = t.id
WHERE (t.project_id = $1 OR (
    ar.task_id IS NOT NULL AND ar.task_id IN (SELECT id FROM tasks WHERE project_id = $1)
))
AND ar.status = 'RUNNING'
ORDER BY ar.started_at ASC
`

type ListActiveAgentRunsByProjectRow struct {
	ID        uuid.UUID   `json:"id"`
	SubtaskID pgtype.UUID `json:"subtask_id"`
	TaskID    uuid.UUID   `json:"task_id"`
	AgentType string      `json:"agent_type"`
	Status    string      `json:"status"`
	LogPath   string      `json:"log_path"`
	StartedAt time.Time   `json:"started_at"`
}

// Returns both Planner runs (task-level) and Worker runs (subtask-level)
func (q *Queries) ListActiveAgentRunsByProject(ctx context.Context, projectID uuid.UUID) ([]ListActiveAgentRunsByProjectRow, error) {
	rows, err := q.db.Query(ctx, listActiveAgentRunsByProject, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveAgentRunsByProjectRow{}
	for rows.Next() {
		var i ListActiveAgentRunsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.SubtaskID,
			&i.TaskID,
			&i.AgentType,
			&i.Status,
			&i.LogPath,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgentRunsBySubtask = `-- name: ListAgentRunsBySubtask :many
SELECT id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id FROM agent_runs
WHERE subtask_id = $1
ORDER BY attempt_number DESC
`

func (q *Queries) ListAgentRunsBySubtask(ctx context.Context, subtaskID pgtype.UUID) ([]AgentRun, error) {
	rows, err := q.db.Query(ctx, listAgentRunsBySubtask, subtaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AgentRun{}
	for rows.Next() {
		var i AgentRun
		if err := rows.Scan(
			&i.ID,
			&i.SubtaskID,
			&i.AgentType,
			&i.AttemptNumber,
			&i.Status,
			&i.StartedAt,
			&i.EndedAt,
			&i.TokenUsage,
			&i.ErrorMessage,
			&i.LogPath,
			&i.PromptText,
			&i.CreatedAt,
			&i.TaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAgentRunsByTask = `-- name: ListAgentRunsByTask :many
SELECT id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id FROM agent_runs
WHERE task_id = $1
ORDER BY attempt_number DESC
`

// For Planner agent runs (task-level)
func (q *Queries) ListAgentRunsByTask(ctx context.Context, taskID pgtype.UUID) ([]AgentRun, error) {
	rows, err := q.db.Query(ctx, listAgentRunsByTask, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AgentRun{}
	for rows.Next() {
		var i AgentRun
		if err := rows.Scan(
			&i.ID,
			&i.SubtaskID,
			&i.AgentType,
			&i.AttemptNumber,
			&i.Status,
			&i.StartedAt,
			&i.EndedAt,
			&i.TokenUsage,
			&i.ErrorMessage,
			&i.LogPath,
			&i.PromptText,
			&i.CreatedAt,
			&i.TaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markStaleAgentRunsFailed = `-- name: MarkStaleAgentRunsFailed :exec
UPDATE agent_runs
SET status = 'FAILED',
    ended_at = NOW(),
    error_message = 'Orchestrator restart - process orphaned'
WHERE status = 'RUNNING'
AND started_at < $1
`

func (q *Queries) MarkStaleAgentRunsFailed(ctx context.Context, startedAt time.Time) error {
	_, err := q.db.Exec(ctx, markStaleAgentRunsFailed, startedAt)
	return err
}

const updateAgentRunStatus = `-- name: UpdateAgentRunStatus :one
UPDATE agent_runs
SET status = $2,
    ended_at = $3,
    error_message = $4
WHERE id = $1
RETURNING id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id
`

type UpdateAgentRunStatusParams struct {
	ID           uuid.UUID          `json:"id"`
	Status       string             `json:"status"`
	EndedAt      pgtype.Timestamptz `json:"ended_at"`
	ErrorMessage *string            `json:"error_message"`
}

func (q *Queries) UpdateAgentRunStatus(ctx context.Context, arg UpdateAgentRunStatusParams) (AgentRun, error) {
	row := q.db.QueryRow(ctx, updateAgentRunStatus,
		arg.ID,
		arg.Status,
		arg.EndedAt,
		arg.ErrorMessage,
	)
	var i AgentRun
	err := row.Scan(
		&i.ID,
		&i.SubtaskID,
		&i.AgentType,
		&i.AttemptNumber,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.TokenUsage,
		&i.ErrorMessage,
		&i.LogPath,
		&i.PromptText,
		&i.CreatedAt,
		&i.TaskID,
	)
	return i, err
}

const updateAgentRunTokenUsage = `-- name: UpdateAgentRunTokenUsage :one
UPDATE agent_runs
SET token_usage = $2
WHERE id = $1
RETURNING id, subtask_id, agent_type, attempt_number, status, started_at, ended_at, token_usage, error_message, log_path, prompt_text, created_at, task_id
`

type UpdateAgentRunTokenUsageParams struct {
	ID         uuid.UUID `json:"id"`
	TokenUsage *int32    `json:"token_usage"`
}

func (q *Queries) UpdateAgentRunTokenUsage(ctx context.Context, arg UpdateAgentRunTokenUsageParams) (AgentRun, error) {
	row := q.db.QueryRow(ctx, updateAgentRunTokenUsage, arg.ID, arg.TokenUsage)
	var i AgentRun
	err := row.Scan(
		&i.ID,
		&i.SubtaskID,
		&i.AgentType,
		&i.AttemptNumber,
		&i.Status,
		&i.StartedAt,
		&i.EndedAt,
		&i.TokenUsage,
		&i.ErrorMessage,
		&i.LogPath,
		&i.PromptText,
		&i.CreatedAt,
		&i.TaskID,
	)
	return i, err
}
